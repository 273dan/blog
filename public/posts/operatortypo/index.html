<!DOCTYPE html>
<html lang="en">
<head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script>
  
    <title>Do as I meant, not as I wrote :: Terminal</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="How a single-character typo corrupted a trading engine with no compiler errors... " />
<meta name="keywords" content=", " />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="http://localhost:1313/blog/posts/operatortypo/" />





  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/fonts.min.b1a9062188e1686924d71d5426faa51da178aa9d7925b00093e1ffeac5e2b923.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/terminal.min.e15721a2ddbb76e0e52020f7a965e83cb18323779d23ab20861e8cdd635ee422.css">

  
  <link rel="stylesheet" href="http://localhost:1313/blog/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="http://localhost:1313/blog/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/blog/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Do as I meant, not as I wrote">
<meta property="og:description" content="How a single-character typo corrupted a trading engine with no compiler errors... " />
<meta property="og:url" content="http://localhost:1313/blog/posts/operatortypo/" />
<meta property="og:site_name" content="Terminal" />

  
  
  <meta property="og:image" content="http://localhost:1313/blog/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-11-23 19:01:37 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/blog/about">
  <div class="logo">
    Dan Kirby
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/blog/about">About</a></li>
        
      
        
          <li><a href="/blog/tags/c&#43;&#43;">C&#43;&#43;</a></li>
        
      
        
          <li><a href="/blog/daniel_kirby_cv_public.pdf">CV</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/blog/about" >About</a></li>
        
      
        
          <li><a href="/blog/tags/c&#43;&#43;" >C&#43;&#43;</a></li>
        
      
        
          <li><a href="/blog/daniel_kirby_cv_public.pdf" >CV</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="http://localhost:1313/blog/posts/operatortypo/">Do as I meant, not as I wrote</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-11-23</time></div>

  
    <span class="post-tags">
      
      #<a href="http://localhost:1313/blog/tags/c&#43;&#43;/">C&#43;&#43;</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h3 id="the-worlds-worst-copy-assignment">The world&rsquo;s worst copy assignment<a href="#the-worlds-worst-copy-assignment" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>I recently experienced a bug so nasty it made me reconsider my proclaimed &ldquo;passion&rdquo; for C++. Working on an implementation of a limit orderbook, I had implemented a <code>cancel</code> method, simply removing an <code>Order</code> object from a <code>std::vector</code> using <code>erase</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">_orders_by_id</span><span class="p">[</span><span class="n">order_id</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="n">orders</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// Note: This is a &#34;Naive Vector&#34; implementation for a future project
</span></span></span><span class="line"><span class="cl"><span class="c1">//       comparing orderbook architectures 
</span></span></span><span class="line"><span class="cl"><span class="c1">//       Iterator invalidation is part of that analysis! 
</span></span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></div><p>But, the <code>Order</code> was never removed. In fact, regardless of which <code>order_id</code> I was attempting to remove, it would remove <strong>only</strong> the last order. After stepping through the function in <code>gdb</code> more times than I care to admit, I checked my implementation of the <code>Order</code> class - and found this abomination.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Order</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Order</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// If two orders have the same id, they are the same order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>At a glance, it appears to be a normal equality comparison operator - but closer inspection of the signature reveals this is in fact the <strong>copy assignment operator!</strong>. I happened to hastily leave off the extra &lsquo;=&rsquo;, thus turning copy assignment into a <strong>no-op</strong> that returns <code>bool</code>.</p>
<p><code>erase</code> works by shifting down all elements after the deletion point, filling the gap left by the deleted item, before shrinking the vector by one. Because I had specified the copy assignment operator, the move assignment operator was thus deleted, forcing the vector to fall back on my broken copy assignment. The shifting became a no-op, and the poor order at the end of the list was truncated. The erroneous <code>bool</code> return value of my copy assignment was silently discarded, and the compiler moved on as if everything were normal. <a href="https://godbolt.org/z/367hacb1d">See an example of my bug on Compiler Explorer</a></p>
<p>After discovering this bug, I did what any sane C++ developer would do and direct my rage towards the compiler instead of accepting I was in the wrong. Why was I allowed to do this in the first place? Why did the code even compile with a clearly incorrect copy assignment operator? <strong>Why does C++ not enforce the return type for operators?</strong> In exploring these questions, I discovered exactly why this apparent anti-pattern actually allows for <strong>incredibly smart optimisation techniques</strong>, and enforcing operator return types would be a <strong>terrible idea</strong>.</p>
<h3 id="operators-are-pure-syntactic-sugar-for-function-calls">Operators are pure syntactic sugar for function calls<a href="#operators-are-pure-syntactic-sugar-for-function-calls" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Unlike many other languages, symbols such as <code>+</code>, <code>-</code>, <code>=</code>, <code>==</code> in C++ are <strong>aliases to function calls</strong>; <code>a + b</code> compiles to an AST node resembling <code>a.operator+(b)</code>. Operators play by the rules of function signatures just like any other function. A function signature is defined by: the name of the function, the number of parameters, and type of parameters. Notably, the <strong>function&rsquo;s return type does not make this list</strong> (which is why you cannot overload a normal function on return type alone). So the compiler can enforce <code>operator=</code> to take exactly one parameter of type <code>const T&amp;</code>, but it does not enforce the return type. This anarchy actually allows us to build things that are impossible in safer languages.</p>
<h3 id="use-cases-for-wrong-operator-overloads">Use cases for &ldquo;wrong&rdquo; operator overloads<a href="#use-cases-for-wrong-operator-overloads" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<h4 id="expression-templates">Expression templates<a href="#expression-templates" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>If C++ decided to enforce strict return types, making <code>operator=</code> always return <code>T&amp;</code> and <code>operator+</code> always return <code>T</code>, it would destroy one of the most powerful optimisation techniques in math - and my latest obsession: <strong>expression templates</strong>.</p>
<p>Consider we are writing a linear algebra library, and we&rsquo;d like to add 3 matrices.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Matrix</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Matrix</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
</span></span></code></pre></div><p>In a return-type-constrained world, <code>(a + b)</code> would first allocate a temporary <code>Matrix</code>, looping through rows and columns to calculate the sum. Then <code>(a + b) + c</code> would allocate <code>result</code>, again looping, before destroying the temporary <code>Matrix</code>. So 2 allocations and 2 loops for a simple addition - unacceptable in low-latency systems.</p>
<p><strong>Expression templates</strong> provide a smart solution to this - and crucially, they depend on the flexibility of operator return types. In libraries like <em>Eigen</em>, <code>Matrix operator+</code> does not return a <code>Matrix</code>, but a lightweight helper object <code>Sum</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Simplified expression template &#34;Sum&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">L</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Sum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">L</span><span class="o">&amp;</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">R</span><span class="o">&amp;</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Keeping it simple for the blog - In production, this may cause dangling
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// references to temporaries!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// This is only computed when required
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">L</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Sum</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">L</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">R</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// operator+ returns this helper, not the actual &#34;result&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">{</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Now, our <code>Matrix</code> addition actually performs no addition - and no allocation. Instead the operators produce a nested structure which looks like <code>Sum{Sum{a, b}, c}</code>. The expression is only <strong>evaluated when it is assigned to <code>result</code></strong>. As well as avoiding the unnecessary allocation, the compiler can also work its magic on this new sum type&hellip;</p>
<h5 id="loop-fusion-and-heap-efficiency">Loop Fusion and Heap Efficiency<a href="#loop-fusion-and-heap-efficiency" class="hanchor" ariaLabel="Anchor">#</a> </h5>
<p>As well as avoiding an allocation, the <code>Sum</code> expression template allows the compiler to generate SIMD instructions, and improves heap efficiency. Take the simple example of a <code>Matrix</code> addition with no expression template:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Matrix</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
</span></span></code></pre></div><p>The CPU is condemned pass over the same memory twice.</p>
<ul>
<li>Pass 1: Load <code>a[i]</code>, load <code>b[i]</code>, add, write temporary result.</li>
<li>Pass 2: Read temporary result, load <code>c[i]</code>, add, write to <code>result</code>.</li>
</ul>
<p>When <code>operator+</code> returns a nested <code>Sum</code>, the computation only happens in the final assignment. The compiler is able to inline this, effectively turning the process into:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The CPU can then:</p>
<ul>
<li>Load <code>a, b</code> and <code>c</code> directly into registers</li>
<li>Sum them <strong>instantly</strong></li>
<li><strong>Write <code>result</code> once</strong></li>
</ul>
<p>Don&rsquo;t just take my word for it! Check out the example on <a href="https://godbolt.org/z/zbcjodK53">Compiler Explorer</a>.</p>
<p>First look at the output for <code>SimpleVecSum</code>. It&rsquo;s huge! Notice the <code>operator new</code> and <code>operator delete</code> on lines 20, 88, 181, 196 and 304 (of compiler output). There&rsquo;s even a <code>memset</code> lurking on line 30. All this heap management vastly slows down the function.</p>
<p>Now look at <code>FastVecSum</code>. It&rsquo;s about a third of the size, and there are precisely zero heap allocations. But <code>clang</code> has done something even smarter here. Look at lines 324-336:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">sub</span>    <span class="no">r9</span><span class="p">,</span> <span class="no">rdi</span>
</span></span><span class="line"><span class="cl"><span class="nf">cmp</span>    <span class="no">r9</span><span class="p">,</span> <span class="mi">128</span>
</span></span><span class="line"><span class="cl"><span class="nf">setb</span>   <span class="no">r9b</span>
</span></span><span class="line"><span class="cl"><span class="c1">; ... repeats for vectors b and c ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">or</span>     <span class="no">r9b</span><span class="p">,</span> <span class="no">r10b</span>
</span></span><span class="line"><span class="cl"><span class="nf">je</span>     <span class="no">.LBB1_5</span>
</span></span></code></pre></div><p>Clang is <strong>checking if the vectors overlap at runtime</strong>. It wants to use 32-byte wide AVX registers to perform the sum, but if the vectors overlap, writing to the destination might overwrite data the source hasn&rsquo;t read yet. The seemingly magic number <code>128</code> actually indicates that the compiler wants to unroll the loop 4 times (8 bytes per double x 4 doubles per register x <strong>4 unrolls</strong> = 128). The <code>sub</code> instruction calculates the distance between vector <code>a</code> and result. If the distance is less than <code>128</code>, it sets the <code>r9b</code> flag - indicating that <code>a</code> and <code>result</code> overlap. If the flag is set, it falls through to <code>.LBB1_2</code>, full of slower - but safer - scalar instructions (<code>vaddsd</code>,<code>vmovsd</code>).</p>
<p>However, if the flag is <strong>not</strong> set, we see beautiful SIMD logic. Look at <code>.LBB1_8</code>, full of &ldquo;packed double&rdquo; SIMD instructions on 32-byte <code>ymm</code> registers. <code>SimpleVecSum</code> is prehistoric in comparison - all enabled because of proxy types, and ultimately, the freedom of operator overloading.</p>
<h4 id="embedded-dsls">Embedded DSLs<a href="#embedded-dsls" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>What if we wanted to completely redefine the role of <code>operator+</code> and <code>operator=</code>. In not all cases does <code>=</code> mean assignment. Take a <strong>constrained optimisation solver</strong> for example. Naturally, you may want to define a constraint. In a rigid world, this may look like as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Solver</span><span class="p">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">Variable</span><span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">},</span> <span class="n">Operator</span><span class="o">::</span><span class="n">EQUALS</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span></code></pre></div><p>While this makes the most sense when working <strong>within the regular world of objects, allocation, and assignment</strong>, we can hijack our operators to let the following code compile:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Symbol</span> <span class="n">x</span><span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Solver</span><span class="p">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);</span>
</span></span></code></pre></div><p>So in this case, <code>operator=</code> doesn&rsquo;t have <strong>anything to do with assignment</strong>, it will perhaps produce a <code>Constraint</code> object or similar.</p>
<h3 id="best-of-both-worlds">Best of Both Worlds<a href="#best-of-both-worlds" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>So it seems the ability to produce lazily evaluated computations and languages-within-languages come at the expense of tormenting beginners who mistake <code>=</code> for <code>==</code>. Luckily, C++20&rsquo;s <code>concepts</code> introduce a way to enforce <strong>semantic intent</strong> without sacrificing <strong>syntactic freedom</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">concept</span> <span class="n">CopyAssignmentActuallyWorks</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Now the compiler will give some &#34;strong guidance&#34; if I mess up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Order</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">static_assert</span><span class="p">(</span><span class="n">CopyAssignmentActuallyWorks</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="p">);</span>
</span></span></code></pre></div><p>While this is overkill for a simple class (and <code>std::assignable</code> does exist), the point is that modern C++ allows us to shift mental capacity used by thinking about safeguards and valid states onto the compiler.</p>
<h3 id="the-code-unfortunately-does-exactly-what-you-wrote">The code (unfortunately) does exactly what you wrote<a href="#the-code-unfortunately-does-exactly-what-you-wrote" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>My one-character typo was permitted based on the assumption that I clearly had a brilliant reason to do so. GCC followed what I <strong>wrote</strong>, not what I <strong>meant</strong> - an effective contract. The architect is given complete freedom and trust by the builder, allowing the builder to build in <strong>the best and most efficient way possible</strong>; we just have to make sure we don&rsquo;t <strong>accidentally design a house with no doors.</strong></p>
<p>Daniel Kirby, November 2025</p>

      </div></div>

  
    

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/blog/bundle.min.js"></script>





  
</div>

</body>
</html>
